<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Seoul Rush â€” Forward Runner</title>
  <style>
    html,body{margin:0;height:100%;background:#f6f7fb;font-family:system-ui,-apple-system,"Noto Sans KR",Arial}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .card{
      width:min(980px,96vw); background:#fff; border:1px solid #e7e9ef;
      border-radius:18px; box-shadow:0 12px 30px rgba(0,0,0,.06); overflow:hidden;
    }
    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #eef0f6}
    .title{font-weight:900;letter-spacing:-.02em}
    .hint{color:#6b7280;font-size:13px}
    .kbd{display:inline-block;padding:2px 8px;border:1px solid #d8dbe6;border-radius:999px;background:#fff;font-weight:800;color:#111827;font-size:12px}
    .stage{position:relative}
    canvas{display:block;width:100%;height:auto;background:#fff;touch-action:manipulation}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
    .panel{
      text-align:center;background:rgba(255,255,255,.92);border:1px solid #e7e9ef;border-radius:16px;
      padding:16px; width:min(460px,88vw); box-shadow:0 14px 34px rgba(0,0,0,.10)
    }
    .panel h2{margin:0 0 6px;font-size:18px;letter-spacing:-.02em}
    .panel p{margin:0;color:#6b7280;font-size:13px;line-height:1.5}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title">Seoul Rush â€” ğŸ§â€â™‚ï¸ vs ğŸ§Ÿ (Forward Runner)</div>
      <div class="hint">
        ì´ë™: <span class="kbd">â†</span><span class="kbd">â†’</span> / í„°ì¹˜(ì¢ŒÂ·ìš°) Â· ì¬ì‹œì‘: <span class="kbd">R</span>
      </div>
    </div>
    <div class="stage">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="overlay" id="ov">
        <div class="panel" id="pn">
          <h2>ì‹œì‘í•˜ê¸°</h2>
          <p>
            <b>â†/â†’</b>ë¡œ ì¢Œìš° ë ˆì¸ì„ ì´ë™í•´ ì¢€ë¹„/ì¥ì• ë¬¼ì„ í”¼í•˜ì„¸ìš”.<br/>
            í™”ë©´ì„ í„°ì¹˜í•´ë„ ì´ë™ë©ë‹ˆë‹¤. (ì¢Œ/ìš° ì˜ì—­ í„°ì¹˜)<br/>
            ì‹œì‘: <span class="kbd">Space</span> ë˜ëŠ” í™”ë©´ í„°ì¹˜
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const ov = document.getElementById("ov");
  const pn = document.getElementById("pn");

  // ---------- Fit canvas in card ----------
  function fit(){
    const w = canvas.parentElement.clientWidth;
    canvas.style.height = Math.round(w * (canvas.height / canvas.width)) + "px";
  }
  window.addEventListener("resize", fit);
  fit();

  // ---------- Storage ----------
  const HI_KEY = "seoul_rush_hi_v1";
  const loadHi = () => Number(localStorage.getItem(HI_KEY) || "0");
  const saveHi = (v) => localStorage.setItem(HI_KEY, String(v));

  // ---------- Math helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));

  // ---------- Perspective / road ----------
  // World z goes from 0..1 (near..far). We spawn at far (z ~ 1.1) and move toward near (z -> 0).
  // Project lane x to screen x with perspective based on z.
  const ROAD = {
    horizonY: 140,
    nearY: 520,
    laneCount: 3,
    laneWidthNear: 380,   // road width at bottom
    laneWidthFar: 120,    // road width near horizon
    centerX: canvas.width/2,
  };

  function laneX(lane){ // lane index -1,0,1
    return lane * 0.62; // normalized sideways
  }

  function project(nx, z){ // nx: normalized lane offset (-1..1-ish), z: 0..1 far
    // p: 0 near, 1 far
    const p = clamp(z, 0, 1);
    const roadW = lerp(ROAD.laneWidthNear, ROAD.laneWidthFar, p);
    const x = ROAD.centerX + nx * (roadW/2);
    const y = lerp(ROAD.nearY, ROAD.horizonY, p);
    const scale = lerp(1.25, 0.24, p); // near bigger
    return { x, y, scale, roadW };
  }

  // ---------- Game state ----------
  const state = {
    started: false,
    running: false,
    over: false,
    t: 0,
    last: 0,
    dt: 0,

    speed: 0.58,         // how fast z decreases per second (higher = faster)
    speedMax: 1.35,
    speedGain: 0.012,    // per second

    score: 0,
    hi: loadHi(),

    obstacles: [],
    deco: [],            // landmarks/cards
    particles: [],

    spawnTimer: 0,
    spawnEvery: 0.9,

    decoTimer: 0,
    decoEvery: 2.6,      // landmarks frequency
    stageLevel: 0,       // grows over time -> more variety
  };

  const player = {
    lane: 0,        // -1,0,1 (target)
    laneX: 0,       // smooth value
    invuln: 0,
  };

  function showOverlay(title, html){
    ov.style.display = "flex";
    pn.querySelector("h2").textContent = title;
    pn.querySelector("p").innerHTML = html;
  }
  function hideOverlay(){ ov.style.display = "none"; }

  function reset(){
    state.started = false;
    state.running = false;
    state.over = false;
    state.t = 0;
    state.score = 0;

    state.speed = 0.58;
    state.obstacles.length = 0;
    state.deco.length = 0;
    state.particles.length = 0;

    state.spawnTimer = 0;
    state.spawnEvery = 0.9;

    state.decoTimer = 0;
    state.decoEvery = 2.6;
    state.stageLevel = 0;

    player.lane = 0;
    player.laneX = 0;
    player.invuln = 0;

    // Spawn a couple early so it doesn't feel empty
    for(let i=0;i<3;i++){
      spawnDeco(true);
    }

    showOverlay(
      "ì‹œì‘í•˜ê¸°",
      "ì •ë©´ìœ¼ë¡œ ë‹¬ë ¤ì˜¤ë©° ì„œìš¸ í’ê²½ ì† ì¢€ë¹„ë¥¼ í”¼í•˜ëŠ” ê²Œì„ì…ë‹ˆë‹¤.<br/>ì‹œì‘: <span class='kbd'>Space</span> ë˜ëŠ” í™”ë©´ í„°ì¹˜ Â· ì´ë™: <span class='kbd'>â†</span><span class='kbd'>â†’</span>"
    );
  }

  // ---------- Content: obstacles & landmarks ----------
  const ZOMBIES = [
    { key:"z_basic",   label:"ì¢€ë¹„",        w:44, h:76 },
    { key:"z_hat",     label:"ê°“ ì¢€ë¹„",     w:48, h:82 },
    { key:"z_mask",    label:"ë§ˆìŠ¤í¬ ì¢€ë¹„", w:46, h:78 },
    { key:"z_nurse",   label:"ê°„í˜¸ì‚¬ ì¢€ë¹„", w:46, h:80 },
    { key:"z_runner",  label:"ëŸ¬ë„ˆ ì¢€ë¹„",   w:44, h:74 },
  ];

  const LANDMARKS = [
    { key:"gwanghwamun", name:"ê´‘í™”ë¬¸",       kind:"arch" },
    { key:"hospital",   name:"ì‘ê¸‰ ë³‘ì›",     kind:"hospital" },
    { key:"namsan",     name:"ë‚¨ì‚°íƒ€ì›Œ",     kind:"tower" },
    { key:"hangang",    name:"í•œê°•ëŒ€êµ",     kind:"bridge" },
    { key:"subway",     name:"ì§€í•˜ì² ì—­",     kind:"subway" },
    { key:"palace",     name:"ê²½ë³µê¶ ì§€ë¶•",  kind:"palace" },
  ];

  function difficulty(){
    // stageLevel grows with time/score; affects spawn density and speed.
    return clamp(state.score / 900, 0, 1);
  }

  function spawnObstacle(){
    const d = difficulty();
    const z = rand(0.86, 1.08); // start far
    const lane = [-1,0,1][randi(0,2)];

    // More variety later
    const poolMax = Math.max(2, Math.floor(2 + d * (ZOMBIES.length-2)));
    const type = ZOMBIES[randi(0, poolMax)];

    state.obstacles.push({
      type,
      lane,
      z,
      // subtle side sway for life
      sway: rand(-0.06, 0.06),
      bob: rand(0, Math.PI*2),
    });
  }

  function spawnDeco(initial=false){
    const d = difficulty();
    const z = initial ? rand(0.75, 0.95) : rand(0.92, 1.18);

    // Landmarks appear more as time passes: allow more types
    const poolMax = Math.max(2, Math.floor(2 + d * (LANDMARKS.length-2)));
    const lm = LANDMARKS[randi(0, poolMax)];

    // Place on left/right side of road (not in lanes)
    const side = Math.random() < 0.5 ? -1 : 1;
    const sideOffset = side * rand(1.15, 1.65);

    state.deco.push({
      lm,
      sideOffset,
      z,
      fade: 0,
    });
  }

  // ---------- Input ----------
  function startGame(){
    state.started = true;
    state.running = true;
    state.over = false;
    hideOverlay();
  }
  function gameOver(){
    state.running = false;
    state.over = true;

    const s = Math.floor(state.score);
    if (s > state.hi){
      state.hi = s;
      saveHi(state.hi);
    }

    showOverlay(
      "GAME OVER",
      `ì ìˆ˜: <b>${s}</b> Â· ìµœê³ : <b>${state.hi}</b><br/>ì¬ì‹œì‘: <span class="kbd">R</span> ë˜ëŠ” í™”ë©´ í„°ì¹˜`
    );
  }
  function moveLeft(){ player.lane = clamp(player.lane - 1, -1, 1); }
  function moveRight(){ player.lane = clamp(player.lane + 1, -1, 1); }

  window.addEventListener("keydown", (e)=>{
    if (e.code === "ArrowLeft") { e.preventDefault(); if(!state.started) startGame(); if(state.running) moveLeft(); }
    if (e.code === "ArrowRight"){ e.preventDefault(); if(!state.started) startGame(); if(state.running) moveRight(); }
    if (e.code === "Space"){ e.preventDefault(); if(!state.started) startGame(); }
    if (e.code === "KeyR"){ e.preventDefault(); reset(); }
  }, { passive:false });

  // touch: left/right half to move, top tap to start
  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;

    if (!state.started) { startGame(); return; }
    if (state.over) { reset(); return; }
    if (!state.running) return;

    if (x < 0.5) moveLeft(); else moveRight();
  }, { passive:false });

  ov.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if (!state.started) startGame();
    else if (state.over) reset();
  }, { passive:false });

  // ---------- Collision ----------
  function collidePlayer(ob){
    // When obstacle is close (z small), check lane match and proximity.
    // zNear threshold where obstacle reaches player.
    const hitZ = 0.12;
    if (ob.z > hitZ) return false;
    // lane match with some forgiveness based on smooth laneX
    const px = player.laneX;
    const ox = ob.lane + ob.sway;
    return Math.abs(px - ox) < 0.42;
  }

  // ---------- Update ----------
  function update(dt){
    state.dt = dt;
    state.t += dt;

    if (!state.running) return;

    // score increases with survival time and speed
    state.score += dt * (140 + state.speed * 260);

    // speed up over time
    state.speed = clamp(state.speed + state.speedGain * dt, 0, state.speedMax);

    // difficulty affects spawn rate
    const d = difficulty();
    state.spawnEvery = lerp(0.92, 0.52, d);
    state.decoEvery  = lerp(2.8, 1.7, d);

    // smooth lane movement
    player.laneX = lerp(player.laneX, player.lane, 1 - Math.pow(0.001, dt)); // framerate independent smoothing

    // timers
    state.spawnTimer += dt;
    state.decoTimer += dt;

    // spawn obstacles: sometimes double spawns later
    if (state.spawnTimer >= state.spawnEvery){
      state.spawnTimer = 0;
      spawnObstacle();
      if (d > 0.45 && Math.random() < 0.28){
        // spawn a second in different lane
        const prevLane = state.obstacles[state.obstacles.length-1].lane;
        const lanes = [-1,0,1].filter(x=>x!==prevLane);
        const ob = state.obstacles[state.obstacles.length-1];
        const type = ZOMBIES[randi(0, Math.max(2, Math.floor(2 + d*(ZOMBIES.length-2))))];
        state.obstacles.push({ type, lane: lanes[randi(0,lanes.length-1)], z: rand(0.9, 1.1), sway: rand(-0.05,0.05), bob: rand(0,Math.PI*2) });
      }
    }
    if (state.decoTimer >= state.decoEvery){
      state.decoTimer = 0;
      spawnDeco(false);
    }

    // move obstacles toward camera (z -> 0)
    for (const ob of state.obstacles){
      ob.z -= state.speed * dt;
      ob.bob += dt * 8;
    }
    // move landmarks
    for (const dc of state.deco){
      dc.z -= state.speed * dt * 0.85;
      dc.fade = clamp(dc.fade + dt*2.2, 0, 1);
    }

    // remove passed
    state.obstacles = state.obstacles.filter(o => o.z > -0.12);
    state.deco = state.deco.filter(d => d.z > -0.2);

    // collision check
    for (const ob of state.obstacles){
      if (collidePlayer(ob)){
        gameOver();
        break;
      }
    }
  }

  // ---------- Draw ----------
  function draw(){
    // background base
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawSky();
    drawSeoulSilhouetteFar();
    drawRoad();

    // draw landmarks behind zombies (sorted by z far->near so far drawn first)
    const decoSorted = [...state.deco].sort((a,b)=>b.z - a.z);
    for (const dc of decoSorted) drawLandmark(dc);

    // draw obstacles (zombies) far->near
    const obsSorted = [...state.obstacles].sort((a,b)=>b.z - a.z);
    for (const ob of obsSorted) drawZombie(ob);

    drawPlayer();

    drawHUD();
    drawVignette();
  }

  function drawSky(){
    ctx.fillStyle = "#f4f6fb";
    ctx.fillRect(0,0,canvas.width,190);
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0,190,canvas.width,180);

    // simple clouds
    ctx.fillStyle = "rgba(203,213,225,0.55)";
    cloud(120, 86, 1.2);
    cloud(320, 64, 0.9);
    cloud(760, 88, 1.1);
  }
  function cloud(x,y,s){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(s,s);
    ctx.beginPath();
    ctx.arc(-28,0,18,0,Math.PI*2);
    ctx.arc(-6,-10,22,0,Math.PI*2);
    ctx.arc(18,0,16,0,Math.PI*2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawSeoulSilhouetteFar(){
    // far skyline blocks + a distant Namsan tower hint
    ctx.fillStyle = "#e9edf7";
    const baseY = 240;
    let x = -40;
    while (x < canvas.width+60){
      const w = 60 + ((x*17)%50+50)%50;
      const h = 25 + ((x*13)%60+60)%60;
      ctx.fillRect(x, baseY - h, w, h);
      x += w + 18;
    }

    // distant tower
    ctx.fillStyle = "#dfe6f4";
    ctx.fillRect(720, baseY - 110, 10, 110);
    ctx.beginPath();
    ctx.roundRect(705, baseY - 145, 40, 34, 10);
    ctx.fill();
    ctx.fillRect(724, baseY - 168, 3, 23);
  }

  function drawRoad(){
    const hY = ROAD.horizonY;
    const nY = ROAD.nearY;

    // road polygon
    ctx.fillStyle = "#eef2ff";
    ctx.beginPath();
    ctx.moveTo(ROAD.centerX - ROAD.laneWidthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.laneWidthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.laneWidthNear/2, nY);
    ctx.lineTo(ROAD.centerX - ROAD.laneWidthNear/2, nY);
    ctx.closePath();
    ctx.fill();

    // edges
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(ROAD.centerX - ROAD.laneWidthFar/2, hY);
    ctx.lineTo(ROAD.centerX - ROAD.laneWidthNear/2, nY);
    ctx.moveTo(ROAD.centerX + ROAD.laneWidthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.laneWidthNear/2, nY);
    ctx.stroke();

    // lane dividers (animated by time)
    const dashCount = 14;
    for (let lane = -1; lane <= 1; lane++){
      if (lane === 1) continue; // dividers between lanes: -0.33 and +0.33 in normalized
    }
    // two divider lines at normalized offsets
    drawDivider(-0.33);
    drawDivider( 0.33);

    function drawDivider(nx){
      for (let i=0;i<dashCount;i++){
        // z position for each dash segment, animate forward movement by shifting phase
        const z = (i / dashCount) + ((state.t * state.speed * 0.55) % 1);
        const zz = z % 1; // 0..1
        const p1 = project(nx, zz);
        const p2 = project(nx, clamp(zz + 0.06, 0, 1));
        ctx.strokeStyle = "rgba(148,163,184,0.55)";
        ctx.lineWidth = Math.max(1.2, p1.scale*2.2);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }
  }

  function drawLandmark(dc){
    const p = project(dc.sideOffset, clamp(dc.z, 0, 1));
    const a = clamp(dc.fade, 0, 1);
    const s = p.scale * 1.05;

    ctx.save();
    ctx.globalAlpha = a * 0.95;
    ctx.translate(p.x, p.y);
    ctx.scale(s, s);

    // little "card" base so landmarks read well
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.strokeStyle = "rgba(203,213,225,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-70, -88, 140, 106, 16);
    ctx.fill();
    ctx.stroke();

    // title
    ctx.fillStyle = "#111827";
    ctx.font = "800 14px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(dc.lm.name, -58, -62);

    // icon drawings
    ctx.translate(0, -18);
    switch(dc.lm.kind){
      case "arch": drawGwanghwamunIcon(); break;
      case "hospital": drawHospitalIcon(); break;
      case "tower": drawTowerIcon(); break;
      case "bridge": drawBridgeIcon(); break;
      case "subway": drawSubwayIcon(); break;
      case "palace": drawPalaceIcon(); break;
      default: drawTowerIcon();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawGwanghwamunIcon(){
    ctx.fillStyle = "#cbd5e1";
    ctx.beginPath();
    ctx.roundRect(-44, -18, 88, 46, 10);
    ctx.fill();
    ctx.fillStyle = "#94a3b8";
    ctx.fillRect(-40, -10, 80, 10);
    ctx.fillStyle = "#64748b";
    ctx.beginPath();
    ctx.moveTo(-46, -18); ctx.lineTo(0, -38); ctx.lineTo(46, -18);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#475569";
    ctx.fillRect(-26, 0, 52, 28);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillRect(-6, 8, 12, 20);
  }

  function drawHospitalIcon(){
    ctx.fillStyle = "#cbd5e1";
    ctx.beginPath(); ctx.roundRect(-44, -26, 88, 58, 10); ctx.fill();
    ctx.fillStyle = "#94a3b8";
    ctx.fillRect(-34, -18, 20, 50);
    ctx.fillRect( 14, -18, 20, 50);
    ctx.fillStyle = "#ef4444";
    ctx.fillRect(-10, -6, 20, 10);
    ctx.fillRect(-4, -18, 8, 34);
    // tiny "ER"
    ctx.fillStyle = "#111827";
    ctx.font = "900 12px system-ui";
    ctx.fillText("ER", -10, 22);
  }

  function drawTowerIcon(){
    ctx.fillStyle = "#cbd5e1";
    ctx.fillRect(-6, -30, 12, 56);
    ctx.fillStyle = "#94a3b8";
    ctx.beginPath(); ctx.roundRect(-24, -56, 48, 30, 12); ctx.fill();
    ctx.fillStyle = "#64748b";
    ctx.fillRect(-2, -72, 4, 18);
    // hill
    ctx.fillStyle = "#e2e8f0";
    ctx.beginPath();
    ctx.moveTo(-52, 28);
    ctx.quadraticCurveTo(0, -2, 52, 28);
    ctx.closePath();
    ctx.fill();
  }

  function drawBridgeIcon(){
    ctx.strokeStyle = "#94a3b8";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(-52, 18);
    ctx.quadraticCurveTo(0, -22, 52, 18);
    ctx.stroke();
    ctx.strokeStyle = "#cbd5e1";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(-60, 18); ctx.lineTo(60, 18);
    ctx.stroke();
    ctx.fillStyle = "#94a3b8";
    ctx.fillRect(-46, 18, 10, 22);
    ctx.fillRect(36, 18, 10, 22);
  }

  function drawSubwayIcon(){
    ctx.fillStyle = "#cbd5e1";
    ctx.beginPath(); ctx.roundRect(-34, -26, 68, 62, 16); ctx.fill();
    ctx.fillStyle = "#3b82f6";
    ctx.beginPath(); ctx.roundRect(-26, -18, 52, 22, 12); ctx.fill();
    ctx.fillStyle = "#111827";
    ctx.font = "900 12px system-ui";
    ctx.fillText("2", -4, -2);
    ctx.fillStyle = "#94a3b8";
    ctx.fillRect(-40, 24, 80, 8);
    // wheels
    ctx.fillStyle = "#64748b";
    ctx.beginPath(); ctx.arc(-18, 36, 6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 18, 36, 6, 0, Math.PI*2); ctx.fill();
  }

  function drawPalaceIcon(){
    ctx.fillStyle = "#cbd5e1";
    ctx.fillRect(-50, 10, 100, 18);
    ctx.fillStyle = "#64748b";
    ctx.beginPath();
    ctx.moveTo(-56, 10);
    ctx.lineTo(0, -22);
    ctx.lineTo(56, 10);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#94a3b8";
    ctx.fillRect(-28, -2, 56, 12);
    ctx.fillStyle = "#475569";
    ctx.fillRect(-36, 0, 10, 28);
    ctx.fillRect( 26, 0, 10, 28);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillRect(-6, 12, 12, 16);
  }

  function drawZombie(ob){
    const p = project(laneX(ob.lane + ob.sway), clamp(ob.z, 0, 1));
    const s = p.scale * 1.15;
    const wob = Math.sin(ob.bob) * 2;

    ctx.save();
    ctx.translate(p.x, p.y + wob);
    ctx.scale(s, s);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(0, 18, 26, 8, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "#16a34a";
    ctx.beginPath();
    ctx.roundRect(-22, -72, 44, 72, 12);
    ctx.fill();

    // head
    ctx.fillStyle = "#22c55e";
    ctx.beginPath();
    ctx.roundRect(-20, -102, 40, 34, 12);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#111827";
    dot(-8, -88, 3);
    dot( 8, -88, 3);

    // mouth
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-10, -78); ctx.lineTo(10, -78);
    ctx.stroke();

    // arms
    ctx.fillStyle = "#15803d";
    ctx.beginPath(); ctx.roundRect(-38, -56, 18, 10, 6); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 20, -48, 18, 10, 6); ctx.fill();

    // accessory by type
    if (ob.type.key === "z_hat"){
      // gat style hat
      ctx.fillStyle = "#111827";
      ctx.beginPath(); ctx.ellipse(0, -106, 30, 6, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.roundRect(-14, -128, 28, 22, 10); ctx.fill();
    } else if (ob.type.key === "z_mask"){
      // mask
      ctx.fillStyle = "#e5e7eb";
      ctx.beginPath(); ctx.roundRect(-18, -82, 36, 16, 8); ctx.fill();
      ctx.strokeStyle = "rgba(17,24,39,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-18, -74); ctx.lineTo(18, -74); ctx.stroke();
    } else if (ob.type.key === "z_nurse"){
      // nurse cap + red cross
      ctx.fillStyle = "#e5e7eb";
      ctx.beginPath(); ctx.roundRect(-18, -122, 36, 18, 8); ctx.fill();
      ctx.fillStyle = "#ef4444";
      ctx.fillRect(-3, -118, 6, 10);
      ctx.fillRect(-8, -113, 16, 6);
    } else if (ob.type.key === "z_runner"){
      // headband
      ctx.fillStyle = "#3b82f6";
      ctx.beginPath(); ctx.roundRect(-20, -100, 40, 10, 8); ctx.fill();
    }

    // feet
    ctx.fillStyle = "#065f46";
    ctx.beginPath(); ctx.roundRect(-18, -6, 16, 10, 5); ctx.fill();
    ctx.beginPath(); ctx.roundRect(2, -6, 16, 10, 5); ctx.fill();

    ctx.restore();
  }

  function drawPlayer(){
    // player is always near bottom center of road; only x changes by laneX
    const p = project(player.laneX*0.62, 0.04); // fixed near z
    const s = 1.12;

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(s, s);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.14)";
    ctx.beginPath();
    ctx.ellipse(0, 22, 30, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "#111827";
    ctx.beginPath();
    ctx.roundRect(-18, -72, 36, 62, 14);
    ctx.fill();

    // shirt
    ctx.fillStyle = "#f8fafc";
    ctx.beginPath();
    ctx.roundRect(-16, -52, 32, 34, 10);
    ctx.fill();

    // jacket edges
    ctx.strokeStyle = "rgba(17,24,39,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -52); ctx.lineTo(0, -20);
    ctx.stroke();

    // head
    ctx.fillStyle = "#f2c9a0";
    ctx.beginPath();
    ctx.roundRect(-16, -104, 32, 34, 14);
    ctx.fill();

    // hair
    ctx.fillStyle = "#111827";
    ctx.beginPath();
    ctx.roundRect(-16, -106, 32, 18, 12);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#111827";
    dot(-6, -90, 2.4);
    dot( 6, -90, 2.4);

    // mouth
    ctx.strokeStyle = "rgba(17,24,39,0.45)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-4, -82); ctx.lineTo(4, -82);
    ctx.stroke();

    // arms
    const walk = state.running ? Math.sin(state.t*10) * 5 : 0;
    ctx.fillStyle = "#111827";
    ctx.beginPath(); ctx.roundRect(-28, -50 + walk, 12, 28, 8); ctx.fill();
    ctx.beginPath(); ctx.roundRect(16, -50 - walk, 12, 28, 8); ctx.fill();

    // legs
    ctx.fillStyle = "#111827";
    ctx.beginPath(); ctx.roundRect(-14, -10, 12, 26, 8); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 2, -10, 12, 26, 8); ctx.fill();

    // shoes
    ctx.fillStyle = "#0f172a";
    ctx.beginPath(); ctx.roundRect(-16, 14, 16, 8, 5); ctx.fill();
    ctx.beginPath(); ctx.roundRect(0, 14, 16, 8, 5); ctx.fill();

    ctx.restore();
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = "#111827";
    ctx.font = "900 18px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`SCORE ${Math.floor(state.score)}`, 18, 30);

    ctx.fillStyle = "#6b7280";
    ctx.font = "800 13px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`HI ${state.hi}`, 18, 52);

    // small stage cue
    const d = difficulty();
    ctx.fillStyle = "#94a3b8";
    ctx.font = "800 12px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`Seoul Mood: ${Math.floor(d*100)}%`, 18, 72);

    ctx.restore();
  }

  function drawVignette(){
    // subtle vignette to enhance depth
    ctx.save();
    ctx.fillStyle = "rgba(15,23,42,0.06)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function dot(x,y,r){
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // ---------- Loop ----------
  function loop(ts){
    if (!state.last) state.last = ts;
    const dt = clamp((ts - state.last)/1000, 0, 0.033);
    state.last = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ---------- Boot ----------
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
