<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>묵검(墨劍) — Ink Sword</title>
  <style>
    html,body{margin:0;height:100%;background:#e9e2cf;font-family:system-ui,-apple-system,"Noto Sans KR",Arial}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .card{
      width:min(1040px,96vw); background:#f1e8d2; border:1px solid rgba(15,23,42,.15);
      border-radius:18px; box-shadow:0 12px 30px rgba(0,0,0,.08); overflow:hidden;
    }
    .topbar{
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      padding:10px 14px;border-bottom:1px solid rgba(15,23,42,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.20), rgba(255,255,255,0));
    }
    .title{font-weight:900;letter-spacing:-.02em;color:rgba(15,23,42,.90)}
    .hint{color:rgba(15,23,42,.65);font-size:13px;line-height:1.25}
    .kbd{
      display:inline-block;padding:2px 8px;border:1px solid rgba(15,23,42,.22);
      border-radius:999px;background:rgba(255,255,255,.55);font-weight:900;color:rgba(15,23,42,.9);font-size:12px
    }
    .stage{position:relative}
    canvas{display:block;width:100%;height:auto;touch-action:none;background:#f1e8d2}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
    .panel{
      text-align:center;background:rgba(241,232,210,.92);border:1px solid rgba(15,23,42,.18);
      border-radius:16px;padding:16px;width:min(560px,92vw);box-shadow:0 14px 34px rgba(0,0,0,.12)
    }
    .panel h2{margin:0 0 6px;font-size:18px;letter-spacing:-.02em;color:rgba(15,23,42,.92)}
    .panel p{margin:0;color:rgba(15,23,42,.70);font-size:13px;line-height:1.55}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title">묵검(墨劍) — 종이 위 먹으로 그린 검 전투</div>
      <div class="hint">
        이동: <span class="kbd">←</span><span class="kbd">→</span> · 점프: <span class="kbd">Space</span> · 베기: <span class="kbd">J</span> · 구르기: <span class="kbd">K</span> · 재시작: <span class="kbd">R</span><br/>
        모바일: 좌/우 드래그 이동 · 탭=베기 · 두 손가락 탭=구르기 · 위쪽 탭=점프
      </div>
    </div>

    <div class="stage">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="overlay" id="ov">
        <div class="panel" id="pn">
          <h2>시작하기</h2>
          <p>
            누런 종이 위 검은 먹으로만 그려진 세계.<br/>
            검객이 되어 <b>베기(J)</b>로 적을 쓰러뜨리세요. <b>구르기(K)</b>는 잠깐 무적입니다.<br/>
            시작: <span class="kbd">Enter</span> / 화면 탭
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });
  const ov = document.getElementById("ov");
  const pn = document.getElementById("pn");

  function fit(){
    const w = canvas.parentElement.clientWidth;
    canvas.style.height = Math.round(w * (canvas.height/canvas.width)) + "px";
  }
  window.addEventListener("resize", fit);
  fit();

  // ---------- Storage ----------
  const HI_KEY = "ink_sword_hi_v1";
  const loadHi = () => Number(localStorage.getItem(HI_KEY) || "0");
  const saveHi = (v) => localStorage.setItem(HI_KEY, String(v));

  // ---------- helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const easeOut = (t)=>1-Math.pow(1-t,3);

  // ---------- Paper texture ----------
  const paper = document.createElement("canvas");
  paper.width = 512; paper.height = 512;
  const pctx = paper.getContext("2d");
  (function makePaper(){
    pctx.fillStyle = "#f1e8d2";
    pctx.fillRect(0,0,paper.width,paper.height);
    // fibers
    for(let i=0;i<12000;i++){
      const x = Math.random()*paper.width;
      const y = Math.random()*paper.height;
      const a = Math.random()*0.06;
      pctx.fillStyle = `rgba(15,23,42,${a})`;
      pctx.fillRect(x,y,1,1);
    }
    // warm wash
    const g = pctx.createRadialGradient(180,160,30, 280,260,420);
    g.addColorStop(0,"rgba(15,23,42,0.06)");
    g.addColorStop(1,"rgba(15,23,42,0)");
    pctx.fillStyle = g;
    pctx.fillRect(0,0,paper.width,paper.height);
  })();

  // ---------- Ink brush primitives (BLACK ONLY) ----------
  function inkAlpha(a){ return `rgba(15,23,42,${a})`; }

  function brushStroke(points, w, a){
    ctx.save();
    ctx.lineCap="round"; ctx.lineJoin="round";
    for(let pass=0; pass<2; pass++){
      ctx.strokeStyle = inkAlpha(a*(pass===0?1:0.7));
      ctx.lineWidth = w*(pass===0?1:0.7);
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const pt = points[i];
        const j = (pass===0?0.6:1.2);
        const x = pt.x + (Math.random()*2-1)*j;
        const y = pt.y + (Math.random()*2-1)*j;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function washCircle(x,y,r,a){
    ctx.save();
    ctx.fillStyle = inkAlpha(a);
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function splatter(x,y, power=1){
    // ink splashes (black only)
    for(let i=0;i<18;i++){
      const ang = Math.random()*Math.PI*2;
      const d = rand(2, 40) * power;
      const rx = x + Math.cos(ang)*d;
      const ry = y + Math.sin(ang)*d;
      const rr = rand(1.2, 6.0) * power;
      const aa = rand(0.05, 0.18);
      washCircle(rx, ry, rr, aa);
    }
  }

  // ---------- UI overlay ----------
  function showOverlay(title, html){
    ov.style.display="flex";
    pn.querySelector("h2").textContent = title;
    pn.querySelector("p").innerHTML = html;
  }
  function hideOverlay(){ ov.style.display="none"; }

  // ---------- Audio (tiny, optional) ----------
  let audioCtx=null;
  function beep(kind="ok"){
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "triangle";
    o.frequency.value = (kind==="hit")?160:(kind==="slash"?520:(kind==="roll"?380:300));
    g.gain.value = 0.0001;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.06, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+(kind==="hit"?0.14:0.09));
    o.stop(t+(kind==="hit"?0.15:0.10));
  }
  function vibrate(ms){ try{ if(navigator.vibrate) navigator.vibrate(ms); }catch{} }

  // ---------- Game constants ----------
  const G = 2200;         // gravity
  const FLOOR_Y = 430;    // ground line
  const WORLD_L = 70;
  const WORLD_R = 890;

  // ---------- State ----------
  const state = {
    started:false, running:false, over:false,
    last:0, t:0,
    score:0, hi:loadHi(),
    wave:1,
    danger:0,

    enemies: [],
    particles: [],

    spawnTimer:0,
    spawnEvery:1.2,

    // hit effects
    shake:0,
    flash:0, // ink veil
    combo:0,
    comboT:0,
  };

  const input = {
    left:false, right:false,
    jumpPressed:false,
    slashPressed:false,
    rollPressed:false,
    // mobile
    pointerDown:false,
    lastPointerX:0,
    drag:false,
    twoFingerTap:false,
  };

  const player = {
    x: 210,
    y: FLOOR_Y,
    vx: 0,
    vy: 0,
    face: 1,        // 1 right, -1 left

    hp: 3,

    // combat
    slashing:false,
    slashT:0,
    slashDur:0.18,
    slashCD:0,

    rolling:false,
    rollT:0,
    rollDur:0.26,
    rollCD:0,
    invuln:0,

    // smooth movement target
    targetX: 210,
  };

  // ---------- Start/reset ----------
  function reset(){
    state.started=false; state.running=false; state.over=false;
    state.last=0; state.t=0;
    state.score=0; state.wave=1; state.danger=0;
    state.enemies.length=0;
    state.particles.length=0;
    state.spawnTimer=0; state.spawnEvery=1.2;
    state.shake=0; state.flash=0;
    state.combo=0; state.comboT=0;

    player.x=210; player.y=FLOOR_Y; player.vx=0; player.vy=0; player.face=1;
    player.hp=3;
    player.slashing=false; player.slashT=0; player.slashCD=0;
    player.rolling=false; player.rollT=0; player.rollCD=0;
    player.invuln=0;
    player.targetX=210;

    showOverlay("시작하기",
      `검은 먹으로만 표현된 세계.<br/>
       베기: <span class="kbd">J</span> · 구르기(무적): <span class="kbd">K</span> · 점프: <span class="kbd">Space</span><br/>
       시작: <span class="kbd">Enter</span> / 화면 탭`
    );
  }

  function startGame(){
    state.started=true; state.running=true; state.over=false;
    hideOverlay();
    if(!audioCtx){
      try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{}
    }
    beep("ok");
  }

  function gameOver(){
    state.running=false; state.over=true;

    const s = Math.floor(state.score);
    if(s > state.hi){ state.hi=s; saveHi(state.hi); }

    showOverlay("패배",
      `점수: <b>${s}</b> · 최고: <b>${state.hi}</b><br/>
       재시작: <span class="kbd">R</span> / 화면 탭`
    );
  }

  // ---------- Input: keyboard ----------
  window.addEventListener("keydown", (e)=>{
    if(e.code==="ArrowLeft"){ e.preventDefault(); if(!state.started) startGame(); input.left=true; player.face=-1; }
    if(e.code==="ArrowRight"){ e.preventDefault(); if(!state.started) startGame(); input.right=true; player.face=+1; }
    if(e.code==="Space"){ e.preventDefault(); if(!state.started) startGame(); input.jumpPressed=true; }
    if(e.code==="KeyJ"){ e.preventDefault(); if(!state.started) startGame(); input.slashPressed=true; }
    if(e.code==="KeyK"){ e.preventDefault(); if(!state.started) startGame(); input.rollPressed=true; }
    if(e.code==="Enter"){ e.preventDefault(); if(!state.started) startGame(); }
    if(e.code==="KeyR"){ e.preventDefault(); reset(); }
  }, {passive:false});
  window.addEventListener("keyup", (e)=>{
    if(e.code==="ArrowLeft") input.left=false;
    if(e.code==="ArrowRight") input.right=false;
  });

  // ---------- Input: mobile ----------
  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if(!state.started){ startGame(); return; }
    if(state.over){ reset(); return; }

    input.pointerDown=true;
    input.drag=true;
    input.lastPointerX = e.clientX;
    canvas.setPointerCapture(e.pointerId);

    // single tap => slash (if not dragging much)
    input.slashPressed = true;
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    if(!input.pointerDown) return;
    const dx = e.clientX - input.lastPointerX;
    input.lastPointerX = e.clientX;

    const rect = canvas.getBoundingClientRect();
    const ndx = dx / rect.width;
    player.targetX += ndx * 900; // pixel-ish scale
    player.targetX = clamp(player.targetX, WORLD_L, WORLD_R);

    if(Math.abs(dx) > 6) input.slashPressed = false; // it was a drag, cancel tap-slash
  });

  canvas.addEventListener("pointerup", ()=>{ input.pointerDown=false; input.drag=false; });
  canvas.addEventListener("pointercancel", ()=>{ input.pointerDown=false; input.drag=false; });

  // two-finger tap => roll
  canvas.addEventListener("touchstart", (e)=>{
    if(e.touches && e.touches.length===2){
      input.rollPressed = true;
      input.twoFingerTap = true;
      setTimeout(()=>input.twoFingerTap=false, 120);
    } else {
      // top area tap => jump
      const rect = canvas.getBoundingClientRect();
      const y = e.touches[0].clientY - rect.top;
      if(y < rect.height*0.28) input.jumpPressed = true;
    }
  }, {passive:true});

  // ---------- Combat helpers ----------
  function tryJump(){
    if(player.y >= FLOOR_Y-0.5){
      player.vy = -860;
      splatter(player.x, player.y-60, 0.5);
      beep("ok");
      vibrate(12);
    }
  }

  function tryRoll(){
    if(player.rollCD>0 || player.rolling) return;
    player.rolling=true;
    player.rollT=0;
    player.rollCD=0.40;
    player.invuln = Math.max(player.invuln, 0.30);
    // burst speed
    player.vx += 860 * player.face;
    beep("roll");
    vibrate(18);
    splatter(player.x, player.y-20, 0.7);
  }

  function trySlash(){
    if(player.slashCD>0 || player.slashing) return;
    player.slashing=true;
    player.slashT=0;
    player.slashCD=0.22;
    beep("slash");
    vibrate(10);
  }

  function slashHitbox(){
    // arc in front of player
    const reach = 96;
    const hx = player.x + player.face*(60);
    const hy = player.y - 70;
    return {x:hx, y:hy, r:reach};
  }

  function damagePlayer(){
    if(player.invuln>0) return;
    player.hp -= 1;
    state.flash = 1;
    state.shake = 10;
    splatter(player.x, player.y-60, 1.1);
    beep("hit");
    vibrate(60);
    player.invuln = 0.65;
    state.combo = 0;
    state.comboT = 0;

    if(player.hp <= 0) gameOver();
  }

  // ---------- Enemy spawn / AI ----------
  function spawnEnemy(){
    const side = Math.random()<0.5 ? -1 : 1;
    const x = side<0 ? rand(WORLD_L, WORLD_L+40) : rand(WORLD_R-40, WORLD_R);
    const speed = rand(120, 200) * (1 + state.wave*0.08);

    state.enemies.push({
      x, y:FLOOR_Y,
      vx: speed * -side,
      hp: 1 + (state.wave>=6 ? 1 : 0),
      kind: (Math.random()<0.2 && state.wave>=4) ? "heavy" : "normal",
      wob: rand(0,Math.PI*2),
      hurt:0,
      atkCD: rand(0.6, 1.2),
    });
  }

  // ---------- Drawing: ink-only scene ----------
  function draw(){
    // camera shake
    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;

    ctx.save();
    ctx.translate(sx, sy);

    // paper base + texture
    ctx.fillStyle = "#f1e8d2";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<canvas.height;y+=paper.height){
      for(let x=0;x<canvas.width;x+=paper.width){
        ctx.drawImage(paper, x, y);
      }
    }

    // ink wash sky
    const sky = ctx.createLinearGradient(0,0,0,280);
    sky.addColorStop(0,"rgba(15,23,42,0.10)");
    sky.addColorStop(1,"rgba(15,23,42,0.00)");
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,canvas.width,300);

    // distant mountains (brush)
    drawMountains();

    // ground line
    brushStroke([{x:40,y:FLOOR_Y+6},{x:920,y:FLOOR_Y+6}], 6, 0.20);

    // drifting ink mist
    drawMist();

    // enemies
    for(const e of state.enemies) drawEnemy(e);

    // player
    drawPlayer();

    // slash effect
    if(player.slashing){
      drawSlashArc();
    }

    // HUD
    drawHUD();

    // flash veil on hit (ink veil)
    if(state.flash>0){
      ctx.fillStyle = `rgba(15,23,42,${0.18*state.flash})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    ctx.restore();
  }

  function drawMountains(){
    const baseY = 280;
    const t = state.t*0.18;
    const pts1 = [];
    for(let i=0;i<=20;i++){
      const x = i*(canvas.width/20);
      const y = baseY + Math.sin(i*0.7 + t)*18 + (i%3)*6;
      pts1.push({x,y});
    }
    // stroke mountain ridge
    brushStroke(pts1, 10, 0.10);
    // fill mountain wash
    ctx.save();
    ctx.fillStyle = "rgba(15,23,42,0.05)";
    ctx.beginPath();
    ctx.moveTo(pts1[0].x, pts1[0].y);
    for(const p of pts1) ctx.lineTo(p.x,p.y);
    ctx.lineTo(canvas.width, baseY+120);
    ctx.lineTo(0, baseY+120);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawMist(){
    const y = 320 + Math.sin(state.t*0.6)*8;
    const g = ctx.createLinearGradient(0,y-20,0,y+70);
    g.addColorStop(0,"rgba(241,232,210,0)");
    g.addColorStop(0.5,"rgba(241,232,210,0.75)");
    g.addColorStop(1,"rgba(241,232,210,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,y-40,canvas.width,140);
  }

  function drawEnemy(e){
    // ink silhouette monster
    const x=e.x, y=e.y;
    const bob = Math.sin(e.wob + state.t*8)*3;

    // shadow
    ctx.fillStyle = inkAlpha(0.10);
    ctx.beginPath(); ctx.ellipse(x, y+6, 34, 10, 0, 0, Math.PI*2); ctx.fill();

    // body wash
    ctx.fillStyle = inkAlpha(0.14 + (e.kind==="heavy"?0.04:0));
    ctx.beginPath();
    ctx.roundRect(x-18, y-78+bob, 36, 72, 14);
    ctx.fill();

    // head wash
    ctx.beginPath();
    ctx.roundRect(x-16, y-112+bob, 32, 34, 14);
    ctx.fill();

    // outline strokes
    brushStroke([{x:x-18,y:y-78+bob},{x:x+18,y:y-78+bob},{x:x+18,y:y-6+bob},{x:x-18,y:y-6+bob},{x:x-18,y:y-78+bob}], 3.4, 0.22);
    brushStroke([{x:x-16,y:y-112+bob},{x:x+16,y:y-112+bob},{x:x+16,y:y-78+bob},{x:x-16,y:y-78+bob},{x:x-16,y:y-112+bob}], 3.0, 0.20);

    // horns (ink)
    brushStroke([{x:x-10,y:y-114+bob},{x:x-26,y:y-132+bob}], 3.2, 0.20);
    brushStroke([{x:x+10,y:y-114+bob},{x:x+26,y:y-132+bob}], 3.2, 0.20);

    // eyes
    ctx.fillStyle = inkAlpha(0.55);
    washCircle(x-6, y-96+bob, 2.6, 0.55);
    washCircle(x+6, y-96+bob, 2.6, 0.55);

    // hurt blink
    if(e.hurt>0){
      ctx.fillStyle = inkAlpha(0.10*e.hurt);
      ctx.fillRect(x-24,y-130,48,140);
    }
  }

  function drawPlayer(){
    const x=player.x, y=player.y;
    const bob = (player.y < FLOOR_Y-0.5) ? 0 : Math.sin(state.t*12)*(Math.abs(player.vx)>10 ? 1.5 : 0.6);

    // invuln aura
    if(player.invuln>0){
      ctx.fillStyle = inkAlpha(0.06 + 0.06*Math.sin(state.t*24));
      ctx.beginPath(); ctx.ellipse(x, y-30, 54, 34, 0, 0, Math.PI*2); ctx.fill();
    }

    // shadow
    ctx.fillStyle = inkAlpha(0.10);
    ctx.beginPath(); ctx.ellipse(x, y+8, 38, 12, 0, 0, Math.PI*2); ctx.fill();

    // robe/body wash
    ctx.fillStyle = inkAlpha(0.12);
    ctx.beginPath(); ctx.roundRect(x-18, y-74+bob, 36, 64, 14); ctx.fill();
    brushStroke([{x:x-18,y:y-74+bob},{x:x+18,y:y-74+bob},{x:x+18,y:y-10+bob},{x:x-18,y:y-10+bob},{x:x-18,y:y-74+bob}], 3.4, 0.22);

    // head
    ctx.fillStyle = inkAlpha(0.06);
    ctx.beginPath(); ctx.roundRect(x-16, y-108+bob, 32, 36, 14); ctx.fill();
    brushStroke([{x:x-16,y:y-108+bob},{x:x+16,y:y-108+bob},{x:x+16,y:y-72+bob},{x:x-16,y:y-72+bob},{x:x-16,y:y-108+bob}], 3.0, 0.18);

    // hair cap
    ctx.fillStyle = inkAlpha(0.16);
    ctx.beginPath(); ctx.roundRect(x-16, y-110+bob, 32, 18, 12); ctx.fill();

    // eyes
    ctx.fillStyle = inkAlpha(0.55);
    washCircle(x-6, y-94+bob, 2.2, 0.55);
    washCircle(x+6, y-94+bob, 2.2, 0.55);

    // sword (in hand)
    const sx = x + player.face*24;
    const sy = y-52+bob;
    brushStroke([{x:sx, y:sy},{x:sx+player.face*54, y:sy-14}], 4.2, 0.22); // blade
    brushStroke([{x:sx, y:sy},{x:sx-player.face*10, y:sy+14}], 4.2, 0.18); // hilt
  }

  function drawSlashArc(){
    const hb = slashHitbox();
    const t = player.slashT / player.slashDur;
    const a = clamp(1 - t, 0, 1);

    // arc curve points
    const pts = [];
    const start = (player.face>0) ? -0.9 : 2.2;
    const end   = (player.face>0) ? 0.8  : 4.0;
    const steps = 10;
    for(let i=0;i<=steps;i++){
      const u = i/steps;
      const ang = lerp(start, end, u);
      pts.push({ x: hb.x + Math.cos(ang)*hb.r, y: hb.y + Math.sin(ang)*hb.r*0.55 });
    }
    brushStroke(pts, 10, 0.18*a);
    splatter(hb.x + player.face*40, hb.y+10, 0.55*a);
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = inkAlpha(0.85);
    ctx.font = "900 18px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`점수 ${Math.floor(state.score)}`, 18, 30);

    ctx.fillStyle = inkAlpha(0.55);
    ctx.font = "900 13px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`최고 ${state.hi}`, 18, 52);

    ctx.fillStyle = inkAlpha(0.70);
    ctx.font = "900 13px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`HP ${player.hp}/3`, 18, 74);

    ctx.fillStyle = inkAlpha(0.55);
    ctx.font = "900 12px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`WAVE ${state.wave}  ·  COMBO ${state.combo}`, 18, 94);

    // small calligraphy seal-like stamp
    ctx.fillStyle = "rgba(15,23,42,0.12)";
    ctx.beginPath(); ctx.roundRect(canvas.width-108, 16, 92, 34, 10); ctx.fill();
    brushStroke([{x:canvas.width-104,y:20},{x:canvas.width-20,y:20},{x:canvas.width-20,y:46},{x:canvas.width-104,y:46},{x:canvas.width-104,y:20}], 2.6, 0.22);
    ctx.fillStyle = inkAlpha(0.80);
    ctx.font = "900 12px system-ui";
    ctx.fillText("墨劍", canvas.width-78, 38);

    ctx.restore();
  }

  // ---------- Update ----------
  function update(dt){
    state.t += dt;

    state.flash = Math.max(0, state.flash - dt*2.8);
    state.shake = Math.max(0, state.shake - dt*18);

    if(!state.running){
      // consume one-shot presses
      input.jumpPressed=false;
      input.slashPressed=false;
      input.rollPressed=false;
      return;
    }

    // difficulty & waves
    state.score += dt * (120 + state.wave*8);
    state.danger = clamp(state.score/1400, 0, 1);

    // wave rises by score
    const targetWave = 1 + Math.floor(state.score / 600);
    if(targetWave > state.wave){
      state.wave = targetWave;
      splatter(480, 200, 1.2);
    }

    // spawn
    state.spawnEvery = lerp(1.25, 0.55, clamp((state.wave-1)/10, 0, 1));
    state.spawnTimer += dt;
    if(state.spawnTimer >= state.spawnEvery){
      state.spawnTimer = 0;
      spawnEnemy();
      if(state.wave>=5 && Math.random()<0.25) spawnEnemy();
    }

    // movement target (keyboard)
    if(input.left)  player.targetX -= 520*dt;
    if(input.right) player.targetX += 520*dt;
    player.targetX = clamp(player.targetX, WORLD_L, WORLD_R);

    // smooth follow (spring)
    const k = 26, c = 2*Math.sqrt(k);
    const ax = k*(player.targetX - player.x) - c*player.vx;
    player.vx += ax*dt;

    // if rolling, add slide impulse, but clamp
    if(player.rolling){
      // keep momentum
      player.vx *= 0.98;
    } else {
      // natural damping
      player.vx *= Math.pow(0.001, dt);
    }

    player.x += player.vx*dt;
    player.x = clamp(player.x, WORLD_L, WORLD_R);

    // jump
    if(input.jumpPressed){ tryJump(); input.jumpPressed=false; }

    // gravity
    player.vy += G*dt;
    player.y += player.vy*dt;
    if(player.y >= FLOOR_Y){
      player.y = FLOOR_Y;
      player.vy = 0;
    }

    // cooldowns
    player.slashCD = Math.max(0, player.slashCD - dt);
    player.rollCD  = Math.max(0, player.rollCD - dt);
    player.invuln  = Math.max(0, player.invuln - dt);

    // actions
    if(input.rollPressed){ tryRoll(); input.rollPressed=false; }
    if(input.slashPressed){ trySlash(); input.slashPressed=false; }

    // slash update + hit
    if(player.slashing){
      player.slashT += dt;
      const hb = slashHitbox();
      // damage window: mid swing
      const t = player.slashT / player.slashDur;
      const dmgOn = (t > 0.18 && t < 0.72);

      if(dmgOn){
        for(let i=state.enemies.length-1;i>=0;i--){
          const e = state.enemies[i];
          const dx = e.x - hb.x;
          const dy = (e.y-80) - hb.y;
          const dist = Math.hypot(dx,dy);

          if(dist < hb.r*0.70){
            // hit
            e.hp -= 1;
            e.hurt = 1;
            state.shake = Math.max(state.shake, 6);
            splatter(e.x, e.y-70, 1.0);
            beep("slash");
            vibrate(12);

            if(e.hp <= 0){
              state.enemies.splice(i,1);
              state.score += 120 + state.wave*18;
              // combo
              state.combo += 1;
              state.comboT = 1.2;
            }
          }
        }
      }

      if(player.slashT >= player.slashDur){
        player.slashing=false;
        player.slashT=0;
      }
    }

    // roll update
    if(player.rolling){
      player.rollT += dt;
      if(player.rollT >= player.rollDur){
        player.rolling=false;
        player.rollT=0;
      } else {
        // during roll, invuln refresh lightly
        player.invuln = Math.max(player.invuln, 0.18);
      }
    }

    // combo decay
    if(state.comboT > 0){
      state.comboT -= dt;
      if(state.comboT <= 0){
        state.comboT = 0;
        state.combo = 0;
      }
    }

    // enemies update + attack collision
    for(const e of state.enemies){
      e.wob += dt*6;
      e.hurt = Math.max(0, e.hurt - dt*4);

      // steer toward player
      const dir = Math.sign(player.x - e.x) || 1;
      const base = (e.kind==="heavy"?120:160) * (1 + state.wave*0.06);
      e.vx = lerp(e.vx, dir*base, 1 - Math.pow(0.001, dt));
      e.x += e.vx*dt;

      // attack if close
      e.atkCD -= dt;
      const close = Math.abs(e.x - player.x) < 46 && Math.abs(player.y - FLOOR_Y) < 2;
      if(close && e.atkCD <= 0){
        e.atkCD = (e.kind==="heavy"?1.05:0.8) - state.wave*0.02;
        e.atkCD = Math.max(0.35, e.atkCD);
        damagePlayer();
      }
    }

    // cleanup (keep inside bounds)
    state.enemies = state.enemies.filter(e => e.x > WORLD_L-120 && e.x < WORLD_R+120);

    // ink veil fades
    if(player.invuln>0 && Math.random() < dt*4){
      // small mist splashes around player during invuln
      washCircle(player.x + rand(-30,30), player.y-50 + rand(-20,20), rand(6,14), 0.03);
    }
  }

  // ---------- Main loop ----------
  function loop(ts){
    if(!state.last) state.last = ts;
    const dt = clamp((ts - state.last)/1000, 0, 0.033);
    state.last = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ---------- Start ----------
  reset();
  requestAnimationFrame(loop);

  // unlock audio on first gesture
  document.addEventListener("pointerdown", ()=>{
    if(!audioCtx){
      try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{}
    }
  }, {once:true});
})();
</script>
</body>
</html>
